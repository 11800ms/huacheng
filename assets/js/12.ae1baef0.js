(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{517:function(a,t,n){"use strict";n.r(t);var r=n(3),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"spring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[a._v("#")]),a._v(" Spring")]),a._v(" "),n("p",[a._v("Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。")]),a._v(" "),n("h2",{attrs:{id:"spring的优势主要体现为以下几点。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring的优势主要体现为以下几点。"}},[a._v("#")]),a._v(" Spring的优势主要体现为以下几点。")]),a._v(" "),n("blockquote",[n("ul",[n("li",[a._v("（1）降低了J2EE的使用难度，并且方便集成各种框架。")]),a._v(" "),n("li",[a._v("（2）推荐及大量使用面向对象设计思想，是学习java源码的经典框架。")]),a._v(" "),n("li",[a._v("（3）面向接口编程，而不是面向类编程，不断的利用Java多态特性及良好的面向对象设计思想，来降低程序的复杂度和耦合度。")]),a._v(" "),n("li",[a._v("（4）提供了测试框架，并且支持集成其他测试框架，使测试更容易，对测试程序的编写也更简单、高效。")])])]),a._v(" "),n("h2",{attrs:{id:"spring框架的设计目标-设计理念-和核心是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring框架的设计目标-设计理念-和核心是什么"}},[a._v("#")]),a._v(" Spring框架的设计目标，设计理念，和核心是什么")]),a._v(" "),n("h3",{attrs:{id:"spring设计目标-spring为开发者提供一个一站式轻量级应用开发平台"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring设计目标-spring为开发者提供一个一站式轻量级应用开发平台"}},[a._v("#")]),a._v(" Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；")]),a._v(" "),n("h3",{attrs:{id:"spring设计理念-在javaee开发中-支持pojo和javabean开发方式-使应用面向接口开发-充分支持oo-面向对象-设计方法-spring通过ioc容器实现对象耦合关系的管理-并实现依赖反转-将对象之间的依赖关系交给ioc容器-实现解耦"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring设计理念-在javaee开发中-支持pojo和javabean开发方式-使应用面向接口开发-充分支持oo-面向对象-设计方法-spring通过ioc容器实现对象耦合关系的管理-并实现依赖反转-将对象之间的依赖关系交给ioc容器-实现解耦"}},[a._v("#")]),a._v(" Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；")]),a._v(" "),n("h3",{attrs:{id:"spring框架的核心-ioc容器和aop模块。通过ioc容器管理pojo对象以及他们之间的耦合关系-通过aop以动态非侵入的方式增强服务。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring框架的核心-ioc容器和aop模块。通过ioc容器管理pojo对象以及他们之间的耦合关系-通过aop以动态非侵入的方式增强服务。"}},[a._v("#")]),a._v(" Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。")]),a._v(" "),n("h2",{attrs:{id:"spring的优点缺点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring的优点缺点"}},[a._v("#")]),a._v(" Spring的优点缺点")]),a._v(" "),n("p",[a._v("优点")]),a._v(" "),n("blockquote",[n("ul",[n("li",[a._v("方便解耦，简化开发")]),a._v(" "),n("li",[a._v("Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。")]),a._v(" "),n("li",[a._v("AOP编程的支持")]),a._v(" "),n("li",[a._v("Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。")]),a._v(" "),n("li",[a._v("声明式事务的支持")]),a._v(" "),n("li",[a._v("只需要通过配置就可以完成对事务的管理，而无需手动编程。")]),a._v(" "),n("li",[a._v("方便程序的测试")]),a._v(" "),n("li",[a._v("Spring对Junit4支持，可以通过注解方便的测试Spring程序。")]),a._v(" "),n("li",[a._v("方便集成各种优秀框架")]),a._v(" "),n("li",[a._v("Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。")]),a._v(" "),n("li",[a._v("降低JavaEE API的使用难度")]),a._v(" "),n("li",[a._v("Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。")]),a._v(" "),n("li")])]),a._v(" "),n("p",[a._v("缺点")]),a._v(" "),n("blockquote",[n("ul",[n("li",[a._v("Spring明明一个很轻量级的框架，却给人感觉大而全")]),a._v(" "),n("li",[a._v("Spring依赖反射，反射影响性能")]),a._v(" "),n("li",[a._v("使用门槛升高，入门Spring需要较长时间")])])]),a._v(" "),n("h2",{attrs:{id:"spring由哪些模块组成"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring由哪些模块组成"}},[a._v("#")]),a._v(" Spring由哪些模块组成")]),a._v(" "),n("p",[a._v("Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：\n"),n("img",{attrs:{src:"https://11800ms.github.io/huacheng/assets/img/java/2021-spring01.png",alt:""}})]),a._v(" "),n("ul",[n("li",[a._v("spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。")]),a._v(" "),n("li",[a._v("spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。")]),a._v(" "),n("li",[a._v("spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。")]),a._v(" "),n("li",[a._v("spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。")]),a._v(" "),n("li",[a._v("spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。")]),a._v(" "),n("li",[a._v("spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。")]),a._v(" "),n("li",[a._v("spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。")])]),a._v(" "),n("h2",{attrs:{id:"spring-框架中都用到了哪些设计模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-框架中都用到了哪些设计模式"}},[a._v("#")]),a._v(" Spring 框架中都用到了哪些设计模式？")]),a._v(" "),n("ul",[n("li",[a._v("工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；")]),a._v(" "),n("li",[a._v("单例模式：Bean默认为单例模式。")]),a._v(" "),n("li",[a._v("代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；")]),a._v(" "),n("li",[a._v("模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。")]),a._v(" "),n("li",[a._v("观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现ApplicationListener。")])]),a._v(" "),n("h2",{attrs:{id:"spring框架中有哪些不同类型的事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring框架中有哪些不同类型的事件"}},[a._v("#")]),a._v(" Spring框架中有哪些不同类型的事件")]),a._v(" "),n("p",[a._v("Spring 提供了以下5种标准的事件：")]),a._v(" "),n("ul",[n("li",[a._v("上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。")]),a._v(" "),n("li",[a._v("上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。")]),a._v(" "),n("li",[a._v("上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。")]),a._v(" "),n("li",[a._v("上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。")]),a._v(" "),n("li",[a._v("请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent -被发布以后，bean会自动被通知。")])]),a._v(" "),n("h2",{attrs:{id:"spring-应用程序有哪些不同组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-应用程序有哪些不同组件"}},[a._v("#")]),a._v(" Spring 应用程序有哪些不同组件？")]),a._v(" "),n("p",[a._v("Spring 应用一般有以下组件：")]),a._v(" "),n("ul",[n("li",[a._v("接口 - 定义功能。")]),a._v(" "),n("li",[a._v("Bean 类 - 它包含属性，setter 和 getter 方法，函数等。")]),a._v(" "),n("li",[a._v("Bean 配置文件 - 包含类的信息以及如何配置它们。")]),a._v(" "),n("li",[a._v("Spring 面向切面编程（AOP） - 提供面向切面编程的功能。")]),a._v(" "),n("li",[a._v("用户程序 - 它使用接口。")])]),a._v(" "),n("h2",{attrs:{id:"使用-spring-有哪些方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-spring-有哪些方式"}},[a._v("#")]),a._v(" 使用 Spring 有哪些方式？")]),a._v(" "),n("p",[a._v("使用 Spring 有以下方式：")]),a._v(" "),n("ul",[n("li",[a._v("作为一个成熟的 Spring Web 应用程序。")]),a._v(" "),n("li",[a._v("作为第三方 Web 框架，使用 Spring Frameworks 中间层。")]),a._v(" "),n("li",[a._v("作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。")]),a._v(" "),n("li",[a._v("用于远程使用。")])]),a._v(" "),n("h2",{attrs:{id:"spring控制反转-ioc-spring-ioc-容器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring控制反转-ioc-spring-ioc-容器"}},[a._v("#")]),a._v(" Spring控制反转(IOC),Spring IOC 容器？")]),a._v(" "),n("ul",[n("li",[a._v("控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。")]),a._v(" "),n("li",[a._v("Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。")])]),a._v(" "),n("h2",{attrs:{id:"控制反转-ioc-有什么作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#控制反转-ioc-有什么作用"}},[a._v("#")]),a._v(" 控制反转(IoC)有什么作用")]),a._v(" "),n("p",[a._v("管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的\n解耦，由容器去维护具体的对象\n托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的")]),a._v(" "),n("h2",{attrs:{id:"ioc的优点是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ioc的优点是什么"}},[a._v("#")]),a._v(" IOC的优点是什么？")]),a._v(" "),n("p",[a._v("IOC 或 依赖注入把应用的代码量降到最低。\n它使应用容易测试，单元测试不再需要单例和JNDI查找机制。\n最小的代价和最小的侵入性使松散耦合得以实现。\nIOC容器支持加载服务时的饿汉式初始化和懒加载。")]),a._v(" "),n("h2",{attrs:{id:"spring-ioc-的实现机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-的实现机制"}},[a._v("#")]),a._v(" Spring IoC 的实现机制")]),a._v(" "),n("p",[a._v("Spring 中的 IoC 的实现原理就是工厂模式加反射机制。\n示例：")]),a._v(" "),n("h2",{attrs:{id:"spring-的-ioc支持哪些功能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-的-ioc支持哪些功能"}},[a._v("#")]),a._v(" Spring 的 IoC支持哪些功能")]),a._v(" "),n("p",[a._v("Spring 的 IoC 设计支持以下功能：")]),a._v(" "),n("ul",[n("li",[a._v("依赖注入")]),a._v(" "),n("li",[a._v("依赖检查")]),a._v(" "),n("li",[a._v("自动装配")]),a._v(" "),n("li",[a._v("支持集合")]),a._v(" "),n("li",[a._v("指定初始化方法和销毁方法")]),a._v(" "),n("li",[a._v("支持回调某些方法（但是需要实现 Spring 接口，略有侵入）")]),a._v(" "),n("li",[a._v("其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。")]),a._v(" "),n("li",[a._v("对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。")])]),a._v(" "),n("h2",{attrs:{id:"applicationcontext通常的实现是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontext通常的实现是什么"}},[a._v("#")]),a._v(" ApplicationContext通常的实现是什么？")]),a._v(" "),n("p",[a._v("FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\nClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。\nWebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。")]),a._v(" "),n("h2",{attrs:{id:"什么是spring的依赖注入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring的依赖注入"}},[a._v("#")]),a._v(" 什么是Spring的依赖注入？")]),a._v(" "),n("p",[a._v("控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找\n依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。")]),a._v(" "),n("h2",{attrs:{id:"依赖注入的基本原则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入的基本原则"}},[a._v("#")]),a._v(" 依赖注入的基本原则")]),a._v(" "),n("p",[a._v("依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。")]),a._v(" "),n("h2",{attrs:{id:"依赖注入有什么优势"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入有什么优势"}},[a._v("#")]),a._v(" 依赖注入有什么优势")]),a._v(" "),n("p",[a._v("依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：")]),a._v(" "),n("ul",[n("li",[a._v("查找定位操作与应用代码完全无关。")]),a._v(" "),n("li",[a._v("不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。")]),a._v(" "),n("li",[a._v("不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。")])]),a._v(" "),n("h2",{attrs:{id:"有哪些不同类型的依赖注入实现方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#有哪些不同类型的依赖注入实现方式"}},[a._v("#")]),a._v(" 有哪些不同类型的依赖注入实现方式？")]),a._v(" "),n("p",[a._v("依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。")]),a._v(" "),n("h3",{attrs:{id:"构造器依赖注入-构造器依赖注入通过容器触发一个类的构造器来实现的-该类有一系列参数-每个参数代表一个对其他类的依赖。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造器依赖注入-构造器依赖注入通过容器触发一个类的构造器来实现的-该类有一系列参数-每个参数代表一个对其他类的依赖。"}},[a._v("#")]),a._v(" 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。")]),a._v(" "),n("h3",{attrs:{id:"setter方法注入-setter方法注入是容器通过调用无参构造器或无参static工厂-方法实例化bean之后-调用该bean的setter方法-即实现了基于setter的依赖注入。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setter方法注入-setter方法注入是容器通过调用无参构造器或无参static工厂-方法实例化bean之后-调用该bean的setter方法-即实现了基于setter的依赖注入。"}},[a._v("#")]),a._v(" Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。")]),a._v(" "),n("h2",{attrs:{id:"构造器依赖注入和-setter方法注入的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造器依赖注入和-setter方法注入的区别"}},[a._v("#")]),a._v(" 构造器依赖注入和 Setter方法注入的区别")]),a._v(" "),n("p",[a._v("两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。")]),a._v(" "),n("h2",{attrs:{id:"什么是spring-beans"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-beans"}},[a._v("#")]),a._v(" 什么是Spring beans？")]),a._v(" "),n("p",[a._v("Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。")]),a._v(" "),n("h2",{attrs:{id:"一个-spring-bean-定义-包含什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一个-spring-bean-定义-包含什么"}},[a._v("#")]),a._v(" 一个 Spring Bean 定义 包含什么？")]),a._v(" "),n("p",[a._v("一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。")]),a._v(" "),n("h2",{attrs:{id:"如何给spring-容器提供配置元数据-spring有几种配置方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何给spring-容器提供配置元数据-spring有几种配置方式"}},[a._v("#")]),a._v(" 如何给Spring 容器提供配置元数据？Spring有几种配置方式")]),a._v(" "),n("p",[a._v("这里有三种重要的方法给Spring 容器提供配置元数据。")]),a._v(" "),n("ul",[n("li",[a._v("XML配置文件。")]),a._v(" "),n("li",[a._v("基于注解的配置。")]),a._v(" "),n("li",[a._v("基于java的配置。")])]),a._v(" "),n("h2",{attrs:{id:"spring配置文件包含了哪些信息"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring配置文件包含了哪些信息"}},[a._v("#")]),a._v(" Spring配置文件包含了哪些信息")]),a._v(" "),n("p",[a._v("Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。")]),a._v(" "),n("h2",{attrs:{id:"spring基于xml注入bean的几种方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring基于xml注入bean的几种方式"}},[a._v("#")]),a._v(" Spring基于xml注入bean的几种方式")]),a._v(" "),n("p",[a._v("Set方法注入；\n构造器注入：①通过index设置参数的位置；②通过type设置参数类型；\n静态工厂注入；\n实例工厂；")]),a._v(" "),n("h2",{attrs:{id:"你怎样定义类的作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#你怎样定义类的作用域"}},[a._v("#")]),a._v(" 你怎样定义类的作用域？")]),a._v(" "),n("p",[a._v("当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。")]),a._v(" "),n("h2",{attrs:{id:"解释spring支持的几种bean的作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解释spring支持的几种bean的作用域"}},[a._v("#")]),a._v(" 解释Spring支持的几种bean的作用域")]),a._v(" "),n("p",[a._v("Spring框架支持以下五种bean的作用域：")]),a._v(" "),n("ul",[n("li",[a._v("singleton : bean在每个Spring ioc 容器中只有一个实例。")]),a._v(" "),n("li",[a._v("prototype：一个bean的定义可以有多个实例。")]),a._v(" "),n("li",[a._v("request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。")]),a._v(" "),n("li",[a._v("session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。")]),a._v(" "),n("li",[a._v("global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。\n注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。")])]),a._v(" "),n("h2",{attrs:{id:"spring框架中的单例bean是线程安全的吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring框架中的单例bean是线程安全的吗"}},[a._v("#")]),a._v(" Spring框架中的单例bean是线程安全的吗？")]),a._v(" "),n("p",[a._v("不是，Spring框架中的单例bean不是线程安全的。\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。")]),a._v(" "),n("ul",[n("li",[a._v("有状态就是有数据存储功能。")]),a._v(" "),n("li",[a._v("无状态就是不会保存数据。")])]),a._v(" "),n("h2",{attrs:{id:"spring如何处理线程并发问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring如何处理线程并发问题"}},[a._v("#")]),a._v(" Spring如何处理线程并发问题？")]),a._v(" "),n("p",[a._v("在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。")]),a._v(" "),n("h2",{attrs:{id:"哪些是重要的bean生命周期方法-你能重载它们吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哪些是重要的bean生命周期方法-你能重载它们吗"}},[a._v("#")]),a._v(" 哪些是重要的bean生命周期方法？ 你能重载它们吗？")]),a._v(" "),n("p",[a._v("有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用\nbean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。")]),a._v(" "),n("h2",{attrs:{id:"什么是spring的内部bean-什么是spring-inner-beans"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring的内部bean-什么是spring-inner-beans"}},[a._v("#")]),a._v(" 什么是Spring的内部bean？什么是Spring inner beans？")]),a._v(" "),n("p",[a._v("在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。")]),a._v(" "),n("h2",{attrs:{id:"在-spring中如何注入一个java集合"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在-spring中如何注入一个java集合"}},[a._v("#")]),a._v(" 在 Spring中如何注入一个java集合？")]),a._v(" "),n("p",[a._v("Spring提供以下几种集合的配置元素：")]),a._v(" "),n("ul",[n("li",[a._v("类型用于注入一列值，允许有相同的值。")]),a._v(" "),n("li",[a._v("类型用于注入一组值，不允许有相同的值。")]),a._v(" "),n("li",[a._v("类型用于注入一组键值对，键和值都可以为任意类型。")]),a._v(" "),n("li",[a._v("类型用于注入一组键值对，键和值都只能为String类型。")])]),a._v(" "),n("h2",{attrs:{id:"什么是bean装配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是bean装配"}},[a._v("#")]),a._v(" 什么是bean装配？")]),a._v(" "),n("p",[a._v("装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。")]),a._v(" "),n("h2",{attrs:{id:"什么是bean的自动装配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是bean的自动装配"}},[a._v("#")]),a._v(" 什么是bean的自动装配？")]),a._v(" "),n("p",[a._v("在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。")]),a._v(" "),n("h2",{attrs:{id:"解释不同方式的自动装配-spring-自动装配-bean-有哪些方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解释不同方式的自动装配-spring-自动装配-bean-有哪些方式"}},[a._v("#")]),a._v(" 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？")]),a._v(" "),n("p",[a._v("在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。\n在Spring框架xml配置中共有5种自动装配：")]),a._v(" "),n("ul",[n("li",[a._v("no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。")]),a._v(" "),n("li",[a._v("byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。")]),a._v(" "),n("li",[a._v("byType：通过参数的数据类型进行自动装配。")]),a._v(" "),n("li",[a._v("constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。")]),a._v(" "),n("li",[a._v("autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。")])]),a._v(" "),n("h2",{attrs:{id:"使用-autowired注解自动装配的过程是怎样的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-autowired注解自动装配的过程是怎样的"}},[a._v("#")]),a._v(" 使用@Autowired注解自动装配的过程是怎样的？")]),a._v(" "),n("p",[a._v("使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。\n在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：")]),a._v(" "),n("ul",[n("li",[a._v("如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；")]),a._v(" "),n("li",[a._v("如果查询的结果不止一个，那么@Autowired会根据名称来查找；")]),a._v(" "),n("li",[a._v("如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。")])]),a._v(" "),n("h2",{attrs:{id:"自动装配有哪些局限性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自动装配有哪些局限性"}},[a._v("#")]),a._v(" 自动装配有哪些局限性？")]),a._v(" "),n("p",[a._v("自动装配的局限性是：")]),a._v(" "),n("ul",[n("li",[a._v("重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。")]),a._v(" "),n("li",[a._v("基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。")]),a._v(" "),n("li",[a._v("模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。")])]),a._v(" "),n("h2",{attrs:{id:"你可以在spring中注入一个null-和一个空字符串吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#你可以在spring中注入一个null-和一个空字符串吗"}},[a._v("#")]),a._v(" 你可以在Spring中注入一个null 和一个空字符串吗？")]),a._v(" "),n("p",[a._v("可以。")]),a._v(" "),n("h2",{attrs:{id:"spring注解-8"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring注解-8"}},[a._v("#")]),a._v(" Spring注解（8）")]),a._v(" "),n("h2",{attrs:{id:"什么是基于java的spring注解配置-给一些注解的例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是基于java的spring注解配置-给一些注解的例子"}},[a._v("#")]),a._v(" 什么是基于Java的Spring注解配置? 给一些注解的例子")]),a._v(" "),n("p",[a._v("基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。\n以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。\n另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。")])])}),[],!1,null,null,null);t.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{516:function(s,a,t){"use strict";t.r(a);var e=t(3),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[s._v("#")]),s._v(" 概述")]),s._v(" "),t("h1",{attrs:{id:"什么是redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis"}},[s._v("#")]),s._v(" 什么是Redis")]),s._v(" "),t("p",[s._v("Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。")]),s._v(" "),t("p",[s._v("Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。")]),s._v(" "),t("p",[s._v("与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。")]),s._v(" "),t("h1",{attrs:{id:"redis有哪些优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis有哪些优缺点"}},[s._v("#")]),s._v(" Redis有哪些优缺点")]),s._v(" "),t("p",[s._v("优点")]),s._v(" "),t("blockquote",[t("ul",[t("li",[s._v("读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。")]),s._v(" "),t("li",[s._v("支持数据持久化，支持AOF和RDB两种持久化方式。")]),s._v(" "),t("li",[s._v("支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。")]),s._v(" "),t("li",[s._v("数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。")]),s._v(" "),t("li",[s._v("支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。")])])]),s._v(" "),t("p",[s._v("缺点")]),s._v(" "),t("blockquote",[t("ul",[t("li",[s._v("数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。")]),s._v(" "),t("li",[s._v("Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。")]),s._v(" "),t("li",[s._v("主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。")]),s._v(" "),t("li",[s._v("Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。")])])]),s._v(" "),t("h1",{attrs:{id:"为什么要用-redis-为什么要用缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用-redis-为什么要用缓存"}},[s._v("#")]),s._v(" 为什么要用 Redis /为什么要用缓存")]),s._v(" "),t("p",[s._v("主要从“高性能”和“高并发”这两点来看待这个问题。")]),s._v(" "),t("h2",{attrs:{id:"高性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高性能"}},[s._v("#")]),s._v(" 高性能")]),s._v(" "),t("p",[s._v("假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！")]),s._v(" "),t("h2",{attrs:{id:"高并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高并发"}},[s._v("#")]),s._v(" 高并发")]),s._v(" "),t("p",[s._v("直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。")]),s._v(" "),t("h2",{attrs:{id:"redis基本命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis基本命令"}},[s._v("#")]),s._v(" Redis基本命令")]),s._v(" "),t("p",[s._v("redis-server：Redis服务器")]),s._v(" "),t("p",[s._v("②、redis-cli：Redis命令行客户端")]),s._v(" "),t("p",[s._v("③、redis-benchmark：Redis性能测试工具")]),s._v(" "),t("p",[s._v("④、redis-check-aof：AOF文件修复工具")]),s._v(" "),t("p",[s._v("⑤、redis-check-rdb：RDB文件检查工具")]),s._v(" "),t("h2",{attrs:{id:"开启aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开启aof"}},[s._v("#")]),s._v(" 开启AOF")]),s._v(" "),t("p",[s._v("将 redis.conf 的 appendonly 配置改为 yes 即可。（给这个单词读出来）")]),s._v(" "),t("h2",{attrs:{id:"主从复制的流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从复制的流程"}},[s._v("#")]),s._v(" 主从复制的流程")]),s._v(" "),t("p",[s._v("1.模拟三台模拟器\n2.对三台模拟器进行修改\n3.通过命令查看redis是否启动\n4.通过命令分别进入这三个redis客户端\n5.设置主从关系\n我们发现这三个节点都是扮演的 Master 角色。现在要将6380和6381节点变为Slave角色。\n6.选择两个端口，执行命令：SLAVEOF 127.0.0.1 6379")]),s._v(" "),t("h3",{attrs:{id:"主从复制的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从复制的原理"}},[s._v("#")]),s._v(" 主从复制的原理")]),s._v(" "),t("p",[s._v("Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作。")]),s._v(" "),t("h3",{attrs:{id:"主从缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从缺点"}},[s._v("#")]),s._v(" 主从缺点")]),s._v(" "),t("p",[s._v("主从复制虽然解决了主节点的单点故障问题，但是由于所有的写操作都是在 Master 节点上操作，然后同步到 Slave 节点，当系统很繁忙的时候，延时问题就会更加严重，而且会随着从节点slave的增多而愈加严重。")]),s._v(" "),t("h2",{attrs:{id:"哨兵模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[s._v("#")]),s._v(" 哨兵模式")]),s._v(" "),t("h3",{attrs:{id:"哨兵模式就是负责站岗的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式就是负责站岗的"}},[s._v("#")]),s._v(" 哨兵模式就是负责站岗的")]),s._v(" "),t("ol",[t("li",[s._v("将redis中的sentinel.conf配置文件复制一份。")]),s._v(" "),t("li",[s._v("修改端口号：")]),s._v(" "),t("li",[s._v("再赋值两份，并修改端口号为5001、5002。")]),s._v(" "),t("li",[s._v("启动6379、6380两个redis和三个哨兵启动：")])]),s._v(" "),t("h2",{attrs:{id:"集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[s._v("#")]),s._v(" 集群")]),s._v(" "),t("h3",{attrs:{id:"为什么要搭建集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要搭建集群"}},[s._v("#")]),s._v(" 为什么要搭建集群")]),s._v(" "),t("p",[s._v("redis-trib.rb 封装了redis提供的集群命令，使用简单、便捷。")]),s._v(" "),t("h3",{attrs:{id:"搭建集群的步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#搭建集群的步骤"}},[s._v("#")]),s._v(" 搭建集群的步骤")]),s._v(" "),t("ol",[t("li",[s._v("因为 redis-trib.rb 是由ruby语言编写的，所以使用该工具需要ruby语言环境的支持")]),s._v(" "),t("li",[s._v("要启用redis-cluster集群，需要先修改redis配置文件集群配置部分的内容（xxxxredis.conf）")]),s._v(" "),t("li",[s._v("开启3台redis服务，查看进程")]),s._v(" "),t("li",[s._v("创建集群")]),s._v(" "),t("li",[s._v("redis-cluster集群至少需要3个可用节点。(这个咱们一定要知道)")]),s._v(" "),t("li",[s._v("当系统因为意外宕机，重启所有节点，集群会自动恢复。")])]),s._v(" "),t("h2",{attrs:{id:"一丶缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一丶缓存穿透"}},[s._v("#")]),s._v(" 一丶缓存穿透")]),s._v(" "),t("h3",{attrs:{id:"缓存穿透-是指查询一个数据库一定不存在的数据。数据查询先进行缓存查询-如果key不存在或者key已经过期-在对数据库进行查询-并把查询到的对象放入到缓存中-如果查询到的为空-则不放进缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透-是指查询一个数据库一定不存在的数据。数据查询先进行缓存查询-如果key不存在或者key已经过期-在对数据库进行查询-并把查询到的对象放入到缓存中-如果查询到的为空-则不放进缓存"}},[s._v("#")]),s._v(" 缓存穿透,是指查询一个数据库一定不存在的数据。数据查询先进行缓存查询，如果key不存在或者key已经过期，在对数据库进行查询，并把查询到的对象放入到缓存中，如果查询到的为空，则不放进缓存")]),s._v(" "),t("h3",{attrs:{id:"代码流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码流程"}},[s._v("#")]),s._v(" 代码流程")]),s._v(" "),t("blockquote",[t("ul",[t("li",[s._v("1.参数传入对象主键Id")]),s._v(" "),t("li",[s._v("2.根据key从缓存中获取对象")]),s._v(" "),t("li",[s._v("3.如果对象不为空，直接返回")]),s._v(" "),t("li",[s._v("4.如果对象为空，进行数据库查询")]),s._v(" "),t("li",[s._v("5.如果这个对象不为空，则放入缓存。'")])])]),s._v(" "),t("h2",{attrs:{id:"二丶缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二丶缓存雪崩"}},[s._v("#")]),s._v(" 二丶缓存雪崩")]),s._v(" "),t("h3",{attrs:{id:"缓存雪崩-是指某一个时间段-缓存集中失效或者过期。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩-是指某一个时间段-缓存集中失效或者过期。"}},[s._v("#")]),s._v(" 缓存雪崩，是指某一个时间段，缓存集中失效或者过期。")]),s._v(" "),t("p",[s._v("如何解决缓存雪崩: 设置不同的过期时间")]),s._v(" "),t("h2",{attrs:{id:"三丶缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三丶缓存击穿"}},[s._v("#")]),s._v(" 三丶缓存击穿")]),s._v(" "),t("h3",{attrs:{id:"缓存击穿是指一个key非常热点-在不停的扛着大并发-大并发集中对一个点进行访问-当这个key在失效的瞬间-持续的大并发就穿破缓存-直接请求数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿是指一个key非常热点-在不停的扛着大并发-大并发集中对一个点进行访问-当这个key在失效的瞬间-持续的大并发就穿破缓存-直接请求数据库"}},[s._v("#")]),s._v(" 缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库")]),s._v(" "),t("p",[s._v("如何解决缓存击穿:让缓存永不过期")])])}),[],!1,null,null,null);a.default=r.exports}}]);